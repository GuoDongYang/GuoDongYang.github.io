[{"title":"weex实战-iOS","date":"2017-01-20T09:41:05.000Z","path":"01/20/weex实战-iOS/","text":"weex学习也有一段时间了，关于weex在三端的使用，我们也做了实战开发，渲染时间在100-300ms之间，各平台体验相比H5都有极大的提升，此文章在iOS的角度记录开发过程中遇到的一些问题，如果想要了解前端和安卓的开发可以参考我同事写的一些内容weex 实践（前端视角）、weex 实践（安卓视角） 准备工作weexSDK接入 Weex iOS SDK 官方集成指南 WXDevtool工具使用 Weex调试神器——Weex Devtools使用手册 订单页实战（weex-iOS相关）接下来我以订单页面为例，来描述一些用到的weex相关知识点，如下图描述 初始化SDK，注册module、protocol、component 12345678910111213/* 在appDelagate里初始化weexSDK并注册module、protocol、component */-(void)initWeex&#123; /* 初始化SDK环境 */ [WXSDKEngine initSDKEnviroment]; /* 自定义module*/ [WXSDKEngine registerModule:@&quot;shopBase&quot; withClass:[BaseModule class]]; [WXSDKEngine registerModule:@&quot;shopModal&quot; withClass:[WXModuleAnno class]]; /* 初始化Protocol*/ [WXSDKEngine registerHandler:[WXImgLoaderDefaultImpl new] withProtocol:@protocol(WXImgLoaderProtocol)]; [WXSDKEngine registerHandler:[WXSJNetworkDefaultlmpl new] withProtocol:@protocol(WXNetworkProtocol)]; /* 初始化Component*/ [WXSDKEngine registerComponent:@&quot;a&quot; withClass:NSClassFromString(@&quot;WXPushComponent&quot;)];&#125; 实现类似选项卡的效果 如图片第一点描述同一个viewcontroller多个view间的切换,此处本店订单和我的订单为不同的view，点击来回切换,达到类似选项卡的效果先贴段渲染weex页面的基础代码 12345678910111213141516171819/*通过JS链接渲染weex页面 会产出一个view*/-(void)renderWeexWithUrl:(NSString *)url&#123; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; CGFloat width = self.view.frame.size.width; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); _instance.onCreate = ^(UIView *view) &#123; /*页面渲染成功 会产出一个view*/ &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; [_instance renderWithURL:[NSURL URLWithString:url] options:@&#123;@&quot;bundleUrl&quot;:url&#125; data:nil];&#125; 如上所述 我们可以针对产出的view进行处理，简单的页面直接添加到self.view上即可。假如需要多个view间的切换，就如订单页的tabbar切换，我这里做了如下处理：把每次新产生的view存到一个字典里，key是链接 value是新产生view ，每次渲染页面前先通过key查找是否已经存在该view，如果已存在把存的view拿出来展示，不存在渲染出来新的view 代码修改如下 123456789101112131415161718192021222324252627282930313233343536373839404142-(void)renderWeexWithUrl:(NSString *)url&#123; /*通过url查找是否已经存在该view 已存在显示出来已有的 不再重新渲染*/ if ([self.mdicViews objectForKey:url] &amp;&amp; [[self.mdicViews objectForKey:url] isKindOfClass:[UIView class]]) &#123; [self loadViewforKey:url]; &#125;else&#123; __weak typeof(self) weakSelf = self; _instance = [[WXSDKInstance alloc] init]; _instance.viewController = self; CGFloat width = self.view.frame.size.width; _instance.frame = CGRectMake(self.view.frame.size.width-width, 0, width, _weexHeight); _instance.onCreate = ^(UIView *view) &#123; /*页面渲染成功 会产出一个view*/ [weakSelf.mdicViews setValue:view forKey:url]; [weakSelf loadViewforKey:url]; &#125;; _instance.onFailed = ^(NSError *error) &#123; &#125;; _instance.renderFinish = ^(UIView *view) &#123; &#125;; _instance.updateFinish = ^(UIView *view) &#123; &#125;; [_instance renderWithURL:[NSURL URLWithString:url] options:@&#123;@&quot;bundleUrl&quot;:url&#125; data:nil]; &#125; &#125; /*通过key显示某个view的操作*/-(void)loadViewforKey:(NSString *)mstrJs&#123; self.weexView = [_mdicViews objectForKey:mstrJs]; [self.view insertSubview:self.weexView atIndex:0]; UIAccessibilityPostNotification(UIAccessibilityScreenChangedNotification, self.weexView); for (int i=0; i&lt;self.view.subviews.count; i++) &#123; UIView * mview = [self.view.subviews objectAtIndex:i]; if (i==0) &#123; mview.hidden=NO; &#125;else&#123; mview.hidden=YES; &#125; &#125;&#125; 自定义a标签component 拦截url进行跳转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 #import &quot;WXPushComponent.h&quot; @interface WXPushComponent() @property (nonatomic, strong) UITapGestureRecognizer *tap; @property (nonatomic, strong) NSString *href; @end @implementation WXPushComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]; if (self) &#123; _tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(openURL)]; _tap.delegate = self; if (attributes[@&quot;href&quot;]) &#123; _href = attributes[@&quot;href&quot;]; &#125; &#125; return self;&#125;- (void)dealloc&#123; if (_tap.delegate) &#123; _tap.delegate = nil; &#125;&#125;- (void)viewDidLoad&#123; [self.view addGestureRecognizer:_tap];&#125;- (void)openURL&#123; if (_href &amp;&amp; [_href length] &gt; 0) &#123; /* a标签的跳转连接 可以根据该链接 进行跳转 */ &#125;&#125;- (void)updateAttributes:(NSDictionary *)attributes&#123; if (attributes[@&quot;href&quot;]) &#123; _href = attributes[@&quot;href&quot;]; &#125;&#125;- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123; if ([gestureRecognizer isKindOfClass:[UITapGestureRecognizer class]] &amp;&amp; [otherGestureRecognizer isKindOfClass:[UITapGestureRecognizer class]]) &#123; return YES; &#125; return NO;&#125;@end 自定义module实现confirm、toast、alert 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 #import &lt;Foundation/Foundation.h&gt; #import &lt;WeexSDK/WXModuleProtocol.h&gt; #import &lt;WeexSDK/WeexSDK.h&gt; @interface WXModuleAnno : NSObject&lt;WXModuleProtocol&gt; @end #import &quot;WXModuleAnno.h&quot; @implementation WXModuleAnno @synthesize weexInstance; WX_EXPORT_METHOD(@selector(toast:)) WX_EXPORT_METHOD(@selector(alert:callback:)) WX_EXPORT_METHOD(@selector(confirm:callback:))- (void)confirm:(NSDictionary *)param callback:(WXModuleCallback)callback&#123; NSString *message = [self stringValue:param[@&quot;message&quot;]]; NSString *okTitle = [self stringValue:param[@&quot;okTitle&quot;]]; NSString *cancelTitle = [self stringValue:param[@&quot;cancelTitle&quot;]]; if (okTitle.length==0) &#123; okTitle = @&quot;确认&quot;; &#125; if (cancelTitle.length==0) &#123; cancelTitle = @&quot;取消&quot;; &#125; /* 此处为自己的弹框组件或者系统的组件 */ /**/ callback(okTitle); &#125;- (void)toast:(NSDictionary *)param&#123; NSString *message = [NSString stringWithFormat:@&quot;%@&quot;,param[@&quot;message&quot;]]; if (!message) return; /* 此处为自己的toast 组件 */ /**/&#125;- (void)alert:(NSDictionary *)param callback:(WXModuleCallback)callback&#123; NSString *message = [self stringValue:param[@&quot;message&quot;]]; NSString *okTitle = [self stringValue:param[@&quot;okTitle&quot;]]; /* 此处为自己的弹框组件或者系统的组件 */ /**/ callback(okTitle);&#125;// 获取当前NVC-(UINavigationController *)currentNVC&#123; return [weexInstance.viewController navigationController];&#125;// 获取当前VC-(UIViewController *)currentVC&#123; return weexInstance.viewController;&#125;- (NSString*)stringValue:(id)value&#123; if ([value isKindOfClass:[NSString class]]) &#123; return value; &#125; if ([value isKindOfClass:[NSNumber class]]) &#123; return [value stringValue]; &#125; return nil;&#125;@end 自定义图片加载protocol,可以对图片进行压缩和缓存的处理 12345678910111213141516171819202122232425262728293031 #import &lt;Foundation/Foundation.h&gt; #import &lt;WeexSDK/WXImgLoaderProtocol.h&gt; @interface WXImgLoaderDefaultImpl : NSObject&lt;WXImgLoaderProtocol&gt; @end #import &quot;WXImgLoaderDefaultImpl.h&quot; #import &lt;SDWebImage/UIImageView+WebCache.h&gt; @interface WXImgLoaderDefaultImpl() @end @implementation WXImgLoaderDefaultImpl #pragma mark - #pragma mark WXImgLoaderProtocol- (id&lt;WXImageOperationProtocol&gt;)downloadImageWithURL:(NSString *)url imageFrame:(CGRect)imageFrame userInfo:(NSDictionary *)userInfo completed:(void(^)(UIImage *image, NSError *error, BOOL finished))completedBlock&#123; if ([url hasPrefix:@&quot;jpg&quot;] || [url hasPrefix:@&quot;png&quot;]) &#123; /* 做相应的处理 */ &#125; return (id&lt;WXImageOperationProtocol&gt;)[[SDWebImageManager sharedManager] downloadImageWithURL:[NSURL URLWithString:url] options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (completedBlock) &#123; completedBlock(image, error, finished); &#125; &#125;];&#125;@end 自定义NetworkProtocol,可以针对网络请求进行拦截修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102 #import &lt;Foundation/Foundation.h&gt; #import &lt;WeexSDK/WeexSDK.h&gt; @interface WXSJNetworkDefaultlmpl : NSObject&lt;WXNetworkProtocol, NSURLSessionDelegate&gt; @end #import &quot;WXSJNetworkDefaultlmpl.h&quot; @interface WXNetworkCallbackInfo : NSObject @property (nonatomic, copy) void(^sendDataCallback)(int64_t, int64_t); @property (nonatomic, copy) void(^responseCallback)(NSURLResponse *); @property (nonatomic, copy) void(^receiveDataCallback)(NSData *); @property (nonatomic, strong) NSMutableData *data; @property (nonatomic, copy) void(^compeletionCallback)(NSData *, NSError *); @end @implementation WXSJNetworkDefaultlmpl &#123; NSMutableDictionary *_callbacks; NSURLSession *_session; &#125;- (id)sendRequest:(NSURLRequest *)request withSendingData:(void (^)(int64_t, int64_t))sendDataCallback withResponse:(void (^)(NSURLResponse *))responseCallback withReceiveData:(void (^)(NSData *))receiveDataCallback withCompeletion:(void (^)(NSData *, NSError *))compeletionCallback&#123; /*拦截了URL 如果没有域名时 添加上域名 为了保持三端同步使用 我们域名放在每个端添加*/ if (![request.URL.absoluteString hasPrefix:@&quot;http&quot;]) &#123; request = [NSURLRequest requestWithURL:[NSURL URLWithString:[NSString stringWithFormat:@&quot;%@%@&quot;,@&quot;&quot;,request.URL.absoluteString]]]; &#125; WXNetworkCallbackInfo *info = [WXNetworkCallbackInfo new]; info.sendDataCallback = sendDataCallback; info.responseCallback = responseCallback; info.receiveDataCallback = receiveDataCallback; info.compeletionCallback = compeletionCallback; if (!_session) &#123; _session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; &#125; NSURLSessionDataTask *task = [_session dataTaskWithRequest:request]; if (!_callbacks) &#123; _callbacks = [NSMutableDictionary dictionary]; &#125; [_callbacks setObject:info forKey:task]; [task resume]; return task;&#125;- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSenttotalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend&#123; WXNetworkCallbackInfo *info = [_callbacks objectForKey:task]; if (info.sendDataCallback) &#123; info.sendDataCallback(totalBytesSent, totalBytesExpectedToSend); &#125;&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)taskdidReceiveResponse:(NSURLResponse *)response completionHandler:(void (^)(NSURLSessionResponseDisposition))completionHandler&#123; WXNetworkCallbackInfo *info = [_callbacks objectForKey:task]; if (info.responseCallback) &#123; info.responseCallback(response); &#125; completionHandler(NSURLSessionResponseAllow);&#125;- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)task didReceiveData:(NSData *)data&#123; WXNetworkCallbackInfo *info = [_callbacks objectForKey:task]; if (info.receiveDataCallback) &#123; info.receiveDataCallback(data); &#125; NSMutableData *mutableData = info.data; if (!mutableData) &#123; mutableData = [NSMutableData new]; info.data = mutableData; &#125; [mutableData appendData:data];&#125;- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; WXNetworkCallbackInfo *info = [_callbacks objectForKey:task]; if (info.compeletionCallback) &#123; info.compeletionCallback(info.data, error); &#125; [_callbacks removeObjectForKey:task];&#125;@end weex native webview 无缝跳转主要讲解如何实现weex native webview间的跳转，达到可以不仅随意跳转并且可以替换native页面的效果以下内容来源于我司安卓大神weex 实践（安卓视角）App的跳转规则的weex支持方案设计跳转规则如下图，如果看不清，可以到新页面放大查看，主要介绍一下两个配置参数： 参数interceptUrlList可以动态配置需要拦截的h5链接，然后生成统一跳转地址 showjoyshop://page.sh/order 示例如下： 12345678910[ &#123; \"page\":\"order\", \"url\":\"https://dshdjshjbx\" &#125;, &#123; \"page\":\"detail\", \"url\":\"https://dsdsds\" &#125;] 然后通过order在参数weexPages里查找对应的js信息，然后渲染 示例如下： 12345678910111213141516[ &#123; \"page\":\"order\", \"url\":\"https://dshdjshjbx.js\", \"md5\":\"323827382huwhdjshdjs\", \"h5\":\"http://dsds.html\" \"v\":\"1.5.0\" &#125;, &#123; \"page\":\"detail\", \"url\":\"https://dsdsds.js\", \"md5\":\"323827382huwhdjshdjs\", \"h5\":\"http://dsds.html\" \"v\":\"1.5.0\" &#125;] url: 需要渲染的js md5: js文件的md5值用于校验 h5: 渲染失败后的降级方案 v: 最低支持的版本号 这样就达到了动态拦截，动态上线weex的目的 预加载weex-JS页面 提高渲染速度主要讲解提前预下载JS文件的逻辑（当然也可以不预下载，直接使用js链接即可）为了提升渲染效率，我们会提前把js文件下载到本地，使用时直接加载本地文件，下载逻辑如下：首先我们会有一个地方录入如下格式的json数据 12345678910111213141516[ &#123; \"page\":\"页面名称\", \"url\":\"js下载链接\", \"md5\":\"js文件MD5\", \"h5\":\"对应的h5页面\" \"v\":\"版本号\" &#125;, &#123; \"page\":\"shoporder\", \"url\":\"https://xxxx.js\", \"md5\":\"js文件MD5\", \"h5\":\"http://xxxx.html\" \"v\":\"1.7.0\" &#125;] page: 对应统一跳转的 path(暂为页面名称) url: 需要渲染的js md5: js文件的md5值用于校验 h5: 渲染失败后的降级方案 v: 最低支持的版本号 然后根据配置文件做如下操作 每次更新完配置文件，遍历，查看是否存在md5一致的page_xxx.js文件，如果不存在则更新 下载完成后，保存格式为xxx.js，校验md5，相同的话，记录文件的最后修改时间，不同的话，删除已下载文件，重新下载，重复校验流程 支持统一跳转协议，page对应目前app端的统一跳转协议里的page，有必要的时候可以替换原来的native页面，解决native页面错误不能及时修复的问题。加载失败的话，打开h5页面 每次打开指定页面的时候，先检查本地是否有对应page文件，再检验最后修改时间是否跟记录的一致，一致就加载，不一致就用线上url 12345第三条提到的统一跳转协议是我们为了解耦各个模块所使用的一种方式，可根据自己的业务做相应的改变我们的就类似：showjoyshop://page.sh/weexshowjoyshop://page.sh/webviewweex对应的就是weex的vc webview对应的就是webview的vc weex和webview即是第三条提到的page ​","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"},{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"}]},{"title":"iOS开发框架搭建系列文章","date":"2013-02-16T03:03:16.000Z","path":"02/16/iOS开发框架搭建系列文章/","text":"此文主要阐述自己在iOS开发中的一些心得，主要在搭建开发框架相关，本文会通过几个章节，从0开始记录。","tags":[{"name":"iOS","slug":"iOS","permalink":"http://yoursite.com/tags/iOS/"},{"name":"框架","slug":"框架","permalink":"http://yoursite.com/tags/框架/"}]}]